<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>NOB Universe ‚Äî JSON Map</title>
<style>
  :root{--fg:#eafaff;--muted:#9ae6ff}
  html,body{margin:0;height:100%;overflow:hidden;background:#000}
  canvas{display:block}
  #hud{position:fixed;inset:auto 10px 10px auto;right:10px;bottom:10px;display:flex;gap:8px;align-items:center}
  #badge{color:var(--muted);font:12px/1.2 Segoe UI,system-ui,sans-serif;background:rgba(0,20,30,.55);padding:6px 10px;border-radius:8px}
  #info{position:fixed;top:10px;left:10px;color:var(--fg);font:14px/1.35 Segoe UI,system-ui,sans-serif;background:rgba(0,0,0,.45);padding:10px 14px;border-radius:10px;max-width:420px}
  #run{padding:6px 10px;border-radius:8px;border:1px solid #1a3a3a;background:rgba(0,50,60,.4);color:#ccfff6;font:12px/1.2 Segoe UI,system-ui,sans-serif;cursor:pointer}
  #tooltip{position:fixed;pointer-events:none;color:#001014;background:#ccfff6;padding:8px 10px;border-radius:8px;box-shadow:0 6px 24px rgba(0,0,0,.35);font:12px/1.25 Segoe UI,system-ui,sans-serif;display:none;max-width:300px;white-space:pre-wrap}
</style>
<!-- Import map so JSM helpers can resolve "three" safely -->
<script type="importmap">{
  "imports":{
    "three":"https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js",
    "three/addons/":"https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/"
  }
}</script>
</head>
<body>
<div id="info">ü™ê <b>NOB Universe ‚Äî JSON Map</b><br/>Click the star to reveal this universe. Click a planet to see its node details. Hover for a quick tooltip.</div>
<div id="tooltip"></div>
<div id="hud"><span id="badge">diag: loading‚Ä¶</span><button id="run" title="Re-run tests">Run tests</button></div>

<!-- Embedded NOB JSON (you can replace this blob and reload) -->
<script id="nob-data" type="application/json">{
  "source":"Chat","conversation_date":"2025-11-09","nodes":[
    {"id":"NOB-20251109-001","title":"Pattern vs Causation Boundary","domain":"Epistemology‚ÜíObviology","core_pattern":"Repeated behavior ‚â† cross-domain causation; pattern as translator","lambda":0.58,"delta":0.31,"psi":0.64,"sense_balance":{"E":2,"L":5,"H":3},"problem":"Overgeneralizing patterns","obstacle":"Category error","path":"Define domain boundaries","tps_breakdown":{"E":"acknowledge","L":"bound","H":"hold"},"janus":"Pattern Similarity ‚Üî Causal Independence","ripple_outcome":"Shared frame for transfer","tags":["pattern","causation","scope","analogy"],"timestamp":"2025-11-09T12:23:00Z"},
    {"id":"NOB-20251109-002","title":"Energy+Constraints Drive Flow","domain":"Physics‚ÜíBehavior","core_pattern":"Direction from energy+constraints not medium alone","lambda":0.66,"delta":0.28,"psi":0.70,"sense_balance":{"E":1,"L":7,"H":2},"problem":"Driver misattribution","obstacle":"Hidden boundary conditions","path":"Map energies/resistances/affordances","tps_breakdown":{"L":"compute","H":"constrain","E":"communicate"},"janus":"Medium Property ‚Üî Boundary Conditions","ripple_outcome":"Causal clarity","tags":["flow","constraints","energy","affordances"],"timestamp":"2025-11-09T12:43:00Z"},
    {"id":"NOB-20251109-003","title":"Transferable Skills vs Domain Lock","domain":"Meta-learning","core_pattern":"Transfer only with structural isomorphism","lambda":0.62,"delta":0.34,"psi":0.68,"sense_balance":{"E":3,"L":6,"H":1},"problem":"Assuming naive transfer","obstacle":"No mapping criteria","path":"Define invariants; test mapping","tps_breakdown":{"L":"map","H":"gate","E":"motivate"},"janus":"Surface Analogy ‚Üî Structural Isomorphism","ripple_outcome":"Safer reuse","tags":["transfer","isomorphism","mapping"],"timestamp":"2025-11-09T12:27:00Z"},
    {"id":"NOB-20251109-004","title":"Prediction vs Record (Cognitive Drift)","domain":"Cognitive Science","core_pattern":"Mind bends record toward prediction","lambda":0.57,"delta":0.45,"psi":0.59,"sense_balance":{"E":5,"L":3,"H":2},"problem":"Post-hoc alignment","obstacle":"Identity-protect bias","path":"Separate prediction/observation logs; reconcile deltas","tps_breakdown":{"H":"separate","L":"compare","E":"normalize"},"janus":"Sanity Coherence ‚Üî Empirical Integrity","ripple_outcome":"Reduced distortion","tags":["prediction","observation","bias","drift"],"timestamp":"2025-11-09T12:43:00Z"},
    {"id":"NOB-20251109-005","title":"Social Ripple of Pattern Disruption","domain":"Social Dynamics","core_pattern":"Disrupting predictions triggers threat & curiosity","lambda":0.50,"delta":0.52,"psi":0.56,"sense_balance":{"E":6,"L":2,"H":2},"problem":"Mixed social response","obstacle":"Threat perception","path":"Pre-signal; reframe; bridge back","tps_breakdown":{"E":"soothe","L":"explain","H":"stabilize"},"janus":"Threat Response ‚Üî Curiosity Reward","ripple_outcome":"Smoother adoption","tags":["disruption","social","novelty"],"timestamp":"2025-11-09T12:43:00Z"}
  ]
}
</script>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // ---- setup ----
  const info = document.getElementById('info');
  const badge = document.getElementById('badge');
  const tooltip = document.getElementById('tooltip');

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 3000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  camera.position.set(0, 120, 280);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;

  scene.add(new THREE.AmbientLight(0xffffff,0.45));
  const sunLight = new THREE.PointLight(0xffffff, 2.2, 4000); scene.add(sunLight);

  // ---- parse input JSON ----
  const raw = document.getElementById('nob-data').textContent;
  /** @type {{source:string,conversation_date:string,nodes:Array<any>}} */
  const DATA = JSON.parse(raw);

  // map domains to color hues (stable across runs)
  const domainColor = (domain)=>{
    const key = String(domain||'').toLowerCase();
    const hash = [...key].reduce((a,c)=>a + c.charCodeAt(0), 0);
    const hue = (hash % 360);
    const col = new THREE.Color().setHSL(hue/360, 0.65, 0.55);
    return col.getHex();
  };

  // central star (conversation)
  const starGeo = new THREE.SphereGeometry(12,64,64);
  const starMat = new THREE.MeshStandardMaterial({color:0xffd27a,emissive:0xffa400,emissiveIntensity:1.0,metalness:0.15,roughness:0.55});
  const star = new THREE.Mesh(starGeo,starMat); scene.add(star);
  let opened = false;

  // Kyber Belt (outer resonance ring)
  const mkKyber = ()=>{
    const count = 800; const geo = new THREE.BufferGeometry();
    const arr = new Float32Array(count*3);
    for(let i=0;i<count;i++){
      const r = 340 + Math.random()*140; const a=Math.random()*Math.PI*2; const y=(Math.random()-0.5)*14;
      arr[i*3] = Math.cos(a)*r; arr[i*3+1] = y; arr[i*3+2] = Math.sin(a)*r;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(arr,3));
    const mat = new THREE.PointsMaterial({color:0x66ffff,size:0.9,transparent:true,opacity:0.6});
    const points = new THREE.Points(geo,mat); points.rotation.x = 0.02; return points;
  };
  const kyber = mkKyber(); scene.add(kyber);

  // Nodes ‚Üí planets
  const planets = [];
  function spawnPlanets(){
    const baseR = 70; const step = 36; // radial spacing between nodes
    DATA.nodes.forEach((n, idx)=>{
      const r = baseR + idx*step; // orbit radius by index
      const color = domainColor(n.domain);
      const size = 3 + (n.psi||0.5)*4; // psi scales radius
      const geo = new THREE.SphereGeometry(size, 24, 24);
      const mat = new THREE.MeshStandardMaterial({color, emissive:color, emissiveIntensity:0.5, metalness:0.2, roughness:0.6});
      const mesh = new THREE.Mesh(geo,mat);
      mesh.userData = { type:'node', node:n, orbitRadius:r, angle:Math.random()*Math.PI*2 };
      scene.add(mesh);
      // orbit ring
      const ring = (()=>{
        const seg=128; const pts=new Float32Array(seg*3);
        for(let i=0;i<seg;i++){ const a=i/seg*Math.PI*2; pts[i*3]=Math.cos(a)*r; pts[i*3+1]=0; pts[i*3+2]=Math.sin(a)*r; }
        const g=new THREE.BufferGeometry(); g.setAttribute('position',new THREE.BufferAttribute(pts,3));
        return new THREE.LineLoop(g,new THREE.LineBasicMaterial({color,transparent:true,opacity:0.2}));
      })();
      scene.add(ring);
      planets.push({mesh, ring});
    });
  }

  // tooltips
  const fmt = (n)=> typeof n==='number'? n.toFixed(2) : n;
  function showTooltip(x,y, n){
    tooltip.style.left = (x+12)+"px"; tooltip.style.top = (y+12)+"px"; tooltip.style.display='block';
    const sb = n.sense_balance || {}; const tags = (n.tags||[]).join(', ');
    tooltip.innerHTML = `<b>${n.id}</b> ‚Äî ${n.title}<br/>`+
      `<small>${n.domain}</small><br/><hr/>`+
      `Œõ ${fmt(n.lambda)} ‚Ä¢ Œî ${fmt(n.delta)} ‚Ä¢ Œ® ${fmt(n.psi)}<br/>`+
      `E/L/H ${sb.E||0}/${sb.L||0}/${sb.H||0}<br/>`+
      `<i>${n.core_pattern}</i><br/>`+
      `<small>Janus: ${n.janus||'-'}</small><br/>`+
      `<small>Tags: ${tags}</small>`;
  }
  function hideTooltip(){ tooltip.style.display='none'; }

  // interaction
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  addEventListener('click', (e)=>{
    mouse.x = (e.clientX/innerWidth)*2-1; mouse.y = -(e.clientY/innerHeight)*2+1;
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(scene.children);
    const obj = hits[0]?.object;
    if(!opened && obj===star){ opened=true; spawnPlanets(); info.textContent = 'Universe loaded ‚Äî click a planet for details; hover to preview.'; return; }
    if(obj?.userData?.type==='node'){
      const n = obj.userData.node;
      info.innerHTML = `üåê <b>${n.title}</b><br/><small>${n.id}</small><br/>${n.core_pattern}`;
      // simple zoom-to target
      const target = obj.position.clone();
      camera.position.lerp(target.clone().add(new THREE.Vector3(18,12,18)), 0.35);
    }
  });
  addEventListener('mousemove',(e)=>{
    mouse.x = (e.clientX/innerWidth)*2-1; mouse.y = -(e.clientY/innerHeight)*2+1;
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(scene.children);
    const obj = hits[0]?.object; if(obj?.userData?.type==='node'){ showTooltip(e.clientX,e.clientY,obj.userData.node); } else { hideTooltip(); }
  });

  // animate
  function animate(){
    requestAnimationFrame(animate);
    controls.update();
    star.rotation.y += 0.002; kyber.rotation.y += 0.0005;
    planets.forEach((p,i)=>{
      const spd = 0.0015 + i*0.0004; p.mesh.userData.angle += spd;
      p.mesh.position.set(Math.cos(p.mesh.userData.angle)*p.mesh.userData.orbitRadius, 0, Math.sin(p.mesh.userData.angle)*p.mesh.userData.orbitRadius);
    });
    renderer.render(scene,camera);
  }
  animate();

  // resize
  addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });

  // ---- diagnostics & tests ----
  const tests=[]; const t=(name,fn)=>{ try{ const ok=!!fn(); tests.push({name,ok}); return ok;}catch(e){ tests.push({name,ok:false,err:e}); return false; } };
  t('three-imported', ()=> typeof THREE.REVISION!=='undefined');
  t('orbitcontrols-ok', ()=> typeof OrbitControls==='function');
  t('json-parsed', ()=> Array.isArray(DATA.nodes) && DATA.nodes.length===5);
  t('domain-color-stable', ()=> domainColor('a')===domainColor('a'));
  t('star-present', ()=> !!star.isMesh);
  // run once on load
  const pass = tests.filter(x=>x.ok).length; badge.textContent = `three r${THREE.REVISION} ‚Ä¢ ${pass}/${tests.length} tests`; console.table(tests);
  document.getElementById('run').addEventListener('click', ()=> location.reload());
  // expose
  window.__NOB_JSON__ = DATA; window.__NOB_TESTS__ = tests;
</script>
</body>
</html>
